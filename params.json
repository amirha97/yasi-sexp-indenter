{"name":"Yasi-sexp-indenter","tagline":"A dialect-aware s-expression indenter written in Python and newLISP","body":"[![Build Status](https://travis-ci.org/nkmathew/yasi-sexp-indenter.svg?branch=master)](https://travis-ci.org/nkmathew/yasi-sexp-indenter)\r\n\r\n##yasi- yet another s-expression indenter\r\nyasi is a dialect-aware s-expression indenter that tries to improve  \r\non [Dorai's indenter][0] and *Vim's* built in indenter. It can handle  \r\n*Common Lisp*, *Clojure*, *Scheme* and *newLISP* code and their  \r\nunique syntaxes.\r\n\r\nIt's a batch mode indenter inspired by Dorai's [lispindent.lisp][1]\r\nthat was written first in *Python* and later translated to *newLISP*.  \r\n\r\nIts style of indentation is  very close to that of *Dorai's* *lispindent.lisp*  \r\nand tries to follow *Dorai's* [style guidelines][0] where reasonable.\r\n(Refer to file dorai-test.lisp)\r\n\r\n\r\n###Features\r\n*yasi's* indentation relies heavily on regular expressions that  \r\ngive it an edge over its counterpart *lispindent.lisp*. Its  \r\nfeatures include:  \r\n\r\n+ Ability to compact code that has extra whitespace between forms.  \r\n  e.g. Code like `(if  (= lisp Clojure ) 'Yes 'No )` is compacted  \r\n  to `(if (= lisp Clojure) 'Yes 'No)`  \r\n\r\n+ Supports 4 dialects of the *Lisp* family giving you the correct indentation  \r\n  of a form according to the dialect's syntax. e.g. The `do` keyword that  \r\n  is used for looping in *Lisp* and sequential execution in *Clojure*.  \r\n  The keyword should look like this in the two dialects:  \r\n\r\n```lisp\r\n;; In Common Lisp\r\n(do ((j 0 (+ j 1)))\r\n    (nil)                       ;Do forever.\r\n  (format t \"~%Input ~D:\" j)\r\n  (let ((item (read)))\r\n    (if (null item) (return)   ;Process items until NIL seen.\r\n      (format t \"~&Output ~D: ~S\" j item))))\r\n\r\n;; In Clojure\r\n(do\r\n (println \"LOG: Computing...\")\r\n (+ 1 1))\r\n```\r\n\r\n+ *yasi* also issues warnings that would become syntax errors if you  \r\n  ran the code. e.g. If you forgot to close a string or a comment.  \r\n\r\n+ Correct indentation of user defined macros. If the `defmacro` keyword is  \r\n  found, the following macro name is added to the list of keywords with indentation  \r\n  level of 2.  \r\n\r\n```lisp\r\n;; from quicklisp.lisp\r\n(defmacro with-connection ((connection host port) &body body)\r\n  `(call-with-connection ,host ,port (lambda (,connection) ,@body)))\r\n\r\n(with-connection (connection (hostname connect-url) (port connect-url))\r\n  (let ((cbuf (make-instance 'cbuf :connection connection))\r\n        (request (request-buffer \"GET\" url)))\r\n    (format stream \"; ~$KB~%\" (/ size 1024))\r\n    (format stream \"; Unknown size~%\")))\r\n```\r\n\r\n+ It indents `flets` and `labels` the right way, using a hack here and there.  \r\n\r\n+ Overkill feature: You get to know the last time you indented the\r\n  file.\r\n\r\n### Command Line Arguments\r\n\r\n    usage: yasi [-h] [-nc] [-nb] [-nm] [-nw] [-no] [-ne] [-o OUTPUT_FILE]\r\n                [--dialect DIALECT] [-v] [-bd BACKUP_DIR] [-di DEFAULT_INDENT]\r\n                [-ic] [-uni]\r\n                [files [files ...]]\r\n\r\n    Dialect-aware s-expression indenter\r\n\r\n    positional arguments:\r\n    files                 List of files to be indented. Will indent from\r\n                            standard input if no files are specified\r\n\r\n    optional arguments:\r\n    -h, --help            show this help message and exit\r\n    -nc, --no-compact     Don't compact the code, just indent\r\n    -nb, --no-backup      Don't create a backup file even if --backup-dir is\r\n                            specified\r\n    -nm, --no-modify      Don't modify the file\r\n    -nw, --no-warning     Don't display warnings\r\n    -no, --no-output      Suppress output of the indented code\r\n    -ne, --no-exit        Instructs the program not to exit when a warning is\r\n                            raised.\r\n    -o OUTPUT_FILE        Path/name of output file\r\n    --dialect DIALECT     Use Scheme keywords\r\n    -v, --version         Prints script version\r\n    -bd BACKUP_DIR, --backup-dir BACKUP_DIR\r\n                            The directory where the backup file is to be written\r\n    -di DEFAULT_INDENT, --default-indent DEFAULT_INDENT\r\n                            The indent level to be used in case a function's\r\n                            argument is in the next line. Vim uses 2, the most\r\n                            common being 1.\r\n    -ic, --indent-comments\r\n                            If true, comment lines will be indented possibly\r\n                            messing with any deliberate comment layout\r\n    -uni, --uniform       Dictates whether the if-clause and else-clause of an\r\n                            if-likeblock should have the same indent level.\r\n\r\n### What yasi does not handle\r\nThere are some syntaxes used in some dialects of scheme that I didn't feel like  \r\nincluding because they are not that common. An example is *MzScheme* and  \r\n*Gauche's* use of `#//` or `#[]` for regular expressions. I just saw it as too  \r\nmuch an effort for something I would not use that often.\r\n\r\n### Customization\r\n*yasi* is customized differently from of Dorai's indenter. Instead of you  \r\nstoring extra keywords in a *.lispwords* file in your home directory, you are  \r\nadvised  to edit the list of keywords in the source file so that you have only  \r\none file. For example, if you find that `multiple-value-bind` should have all  \r\nof its subforms indented uniformly like so:  \r\n\r\n```lisp\r\n(multiple-value-bind (f r)\r\n  (floor 130 11)\r\n  (list f r))\r\n```\r\n\r\nInstead of:  \r\n\r\n```lisp\r\n(multiple-value-bind (f r)\r\n    (floor 130 11)\r\n  (list f r))\r\n```\r\n\r\nYou go to *line 424(yasi.py)*:  \r\n\r\n```python\r\nif DIALECT == 'Common Lisp': # Lisp\r\n    TWO_SPACE_INDENTERS = LISP_KEYWORDS\r\n    IF_LIKE += ['multiple-value-bind', 'destructuring-bind', 'do', 'do*']\r\n```\r\nand simply remove `multiple-value-bind` from the list.\r\n\r\n#### About the default indent\r\n\r\nThe *--default-indent* comes in in expressions whose subforms usually  \r\nstart in the subsequent lines. Like a `cond` expression:  \r\n\r\n```lisp\r\n(cond\r\n ((> this that) 'Yes)\r\n ((= those these) 'No))\r\n```\r\n\r\nAccording to Dorai's [guidelines][0]\r\nthe above indentation is correct. However,  \r\nsome people may prefer the test expressions to be two spaces past the bracket,  \r\nlike this:  \r\n\r\n```lisp\r\n(cond\r\n  ((> newLISP CL) 'Yes)\r\n  ((= Clojure Lisp) 'No))\r\n```\r\n\r\nThis is *Vim's* default style of indentation.  \r\nThat option enables you to specify the amount you want, for example to achieve  \r\nthe style above, you pass the parameter like so:\r\n\r\n    yasi.py test.lisp --lisp --default-indent 2\r\n\r\n----------\r\n\r\n#### Changes made to Dorai's Indenter\r\nI made a couple of modifications to *lispindent.lisp* and renamed it to  \r\n*lispindent2.lisp*. It contains some of *yasi's* features. The changes  \r\ninclude:  \r\n\r\n+ Added comments for some sections of the program that took me time to grok.   \r\n\r\n+ It can now indent files from the command line without the need to redirect  \r\n  file contents to the program.\r\n\r\n+ *lispindent2.lisp* indents *Clojure's* *vectors* and *sets*  \r\n  better, i.e with an indentation level of 1, without affecting  \r\n  *lisp* or *scheme's indentation*. It uses the file's extension to determine  \r\n  if it's looking at *Clojure* code.\r\n  e.g.\r\n\r\n```lisp\r\n;; lispindent2.lisp's indentation\r\n(print {define \"The keyword does not affect indentation\"\r\n    })\r\n\r\n;; lispindent.lisp's indentation\r\n(print {define \"The keyword does not affect indentation\"\r\n   })\r\n```\r\n\r\n+ *lispindent2.lisp* ignores any code in a multiline comment and won't  \r\n  be affected by any unclosed brackets inside the comment like the original  \r\n  version. Unfortunately, its method of detecting multiline comments is rather  \r\n  naive and introduces a bug in the code. Refer to its issues below.  \r\n\r\n* *lispindent2.lisp* writes files using *LF* line endings be default. It's less  \r\n  irritating than *CRLF* endings which usually light up in an annoying way in *Vim*.  \r\n\r\n#### lispindent2.lisp's Issues\r\n\r\nI inadvertently added a bug in an attempt to prevent it from evaluating  \r\nbrackets inside multiline comments and symbols with whitespace. It uses the pipe  \r\ncharacter(|) to switch between `multiline-commentp=T` and `multiline-commentp=NIL`  \r\nwhich means that if your pipes are unbalanced, you'll get wrong indentation, e.g.:  \r\n\r\n```lisp\r\n#|*******************************************************************|\r\n |   This is a multiline comment that will trip the indenter         |\r\n |   because the odd number of pipes will cause `multiline-commentp` |\r\n |   to be true after this comment. It means the rest of the code    |\r\n |   won't be indented because it thinks it's still in a comment.    |\r\n          Total pipes=11(odd)\r\n |#\r\n (print (cons\r\n    'Hello ;; This line and the one below won't change\r\n    'World\r\n        ))\r\n```\r\n\r\nI don't find this to be a major issue because multiline comments are rare,  \r\nthe common use case being to comment out some piece of code when debugging.  \r\n\r\n*lispindent2.lisp* uses the *Lisp* reader function `read-from-string` to get  \r\nlisp forms and atoms from the read string. The downside of this is that  \r\n`read-from-string` will fail when the code in the string is 'malformed'.  \r\nFor example, if it finds that the dot operator used for consing in *Common Lisp*  \r\ncomes after the opening bracket, it will raise a fatal error. This  \r\nmeans that any *Clojure* code that tries to use the dot operator to access a  \r\nclass method will not be indented because of the error. An example is this code:  \r\n\r\n```lisp\r\n(defmacro chain\r\n  ([x form] `(. ~x ~form))\r\n  ([x form & more] `(chain (. ~x ~form) ~@more)))\r\n```\r\n\r\n*lispindent2.lisp* uses the `ignore-errors` macro as a workaround. Doing that means that it can't  \r\nrun in *GNU Common Lisp* because it doesn't have the macro.\r\n\r\n#### lispindent2.lisp's command-line options\r\n     ___________________________________________________________________________\r\n    |   Usage:  lispindent2.lisp [[<file>] [--no-modify] [--no-output]]         |\r\n    |           --no-output ;; Don't output the indented code, false by default |\r\n    |           --no-modify ;; Don't modify the file, false by default          |\r\n    +---------------------------------------------------------------------------+\r\n\r\n[0]: http://ds26gte.github.io/scmindent/index.html\r\n[1]: https://github.com/ds26gte/scmindent/blob/master/lispindent.lisp\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}